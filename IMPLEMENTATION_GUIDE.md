# HashStamp Enhancement Plan - Implementation Guide

This document provides actionable implementation guidance for the HashStamp enhancement plan. It serves as a practical companion to the strategic roadmap outlined in `ENHANCEMENT_PLAN.md`.

## Quick Start Implementation

For developers looking to contribute to HashStamp enhancements, start with these foundational tasks:

### Immediate Actions (Week 1-2)

#### 1. Set Up Development Environment
```bash
# Clone and build
git clone https://github.com/alexwiese/hashstamp.git
cd hashstamp
dotnet restore
dotnet build

# Verify current functionality
dotnet run --project src/HashStamp.Test/HashStamp.Test.csproj
```

#### 2. Create Testing Framework Foundation
Priority task to enable reliable development:

```bash
# Create test project
dotnet new xunit -n HashStamp.Tests -o src/HashStamp.Tests
cd src/HashStamp.Tests
dotnet add package Microsoft.CodeAnalysis.Testing.Verifiers.XUnit
dotnet add package Microsoft.CodeAnalysis.CSharp.Testing
dotnet add reference ../HashStamp/HashStamp.csproj
```

**First Test Example**:
```csharp
[Fact]
public async Task GenerateHashStamps_SimpleMethod_GeneratesCorrectHash()
{
    var source = @"
using System;
namespace TestNamespace
{
    public class TestClass
    {
        public string TestMethod()
        {
            return ""Hello, World!"";
        }
    }
}";

    var expected = @"
// <auto-generated/>
using System.Collections.ObjectModel;

namespace HashStamp;

public static partial class HashStamps
{
    // Generated content verification
}";

    await new CSharpSourceGeneratorTest<HashStampGenerator>()
    {
        TestCode = source,
        ExpectedDiagnostics = { },
        // Add expected generated sources
    }.RunAsync();
}
```

### Phase 1 Implementation Details

#### Enhanced Language Construct Support

**Properties Support Implementation**:

1. **Extend Syntax Provider**:
```csharp
// In HashStampGenerator.cs, update the syntax provider:
var syntaxProvider = context.SyntaxProvider
    .CreateSyntaxProvider(
        predicate: static (node, _) => node is MethodDeclarationSyntax 
                                    or PropertyDeclarationSyntax 
                                    or ConstructorDeclarationSyntax,
        transform: static (context, _) => context.Node)
    .Where(node => node is not null);
```

2. **Create Member Info Base Class**:
```csharp
public abstract class MemberHashInfo
{
    public string Namespace { get; }
    public string ClassName { get; }
    public string Name { get; }
    public string Hash { get; }
    public abstract string QualifiedName { get; }
}

public class MethodHashInfo : MemberHashInfo { /* existing implementation */ }
public class PropertyHashInfo : MemberHashInfo { /* new implementation */ }
public class ConstructorHashInfo : MemberHashInfo { /* new implementation */ }
```

**MSBuild Configuration Implementation**:

1. **Create Configuration Class**:
```csharp
public class HashStampConfiguration
{
    public string HashAlgorithm { get; set; } = "SHA256";
    public string ClassName { get; set; } = "HashStamps";
    public string Namespace { get; set; } = "HashStamp";
    public HashSet<string> IncludeNamespaces { get; set; } = new();
    public HashSet<string> ExcludeNamespaces { get; set; } = new();
    
    public static HashStampConfiguration FromAnalyzerOptions(AnalyzerConfigOptionsProvider optionsProvider)
    {
        // Parse MSBuild properties from optionsProvider
        var config = new HashStampConfiguration();
        
        if (optionsProvider.GlobalOptions.TryGetValue("hashstamp_algorithm", out var algorithm))
            config.HashAlgorithm = algorithm;
            
        // Parse other properties...
        return config;
    }
}
```

2. **Update Generator to Use Configuration**:
```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    var configProvider = context.AnalyzerConfigOptionsProvider
        .Select(static (options, _) => HashStampConfiguration.FromAnalyzerOptions(options));
        
    var combinedProvider = context.CompilationProvider
        .Combine(syntaxProvider.Collect())
        .Combine(configProvider);
        
    context.RegisterSourceOutput(combinedProvider, 
        static (ctx, source) => Execute(source.Left.Left, source.Left.Right, source.Right, ctx));
}
```

#### NuGet Package Setup

**Update HashStamp.csproj**:
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <OutputType>Library</OutputType>
    <IsRoslynAnalyzer>true</IsRoslynAnalyzer>
    
    <!-- NuGet Package Properties -->
    <PackageId>HashStamp</PackageId>
    <PackageVersion>1.0.0</PackageVersion>
    <Authors>Alex Wiese</Authors>
    <Description>A .NET Roslyn incremental source generator that analyzes source code and generates SHA-256 hash values for method bodies.</Description>
    <PackageProjectUrl>https://github.com/alexwiese/hashstamp</PackageProjectUrl>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageTags>roslyn;sourcegenerator;hash;sha256;codeanalysis;dotnet</PackageTags>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
    <IncludeBuildOutput>false</IncludeBuildOutput>
  </PropertyGroup>
  
  <!-- Existing dependencies and configuration -->
</Project>
```

### Phase 2 Implementation Priorities

#### Attribute-Based Control

**Create Attribute Assembly**:
```bash
dotnet new classlib -n HashStamp.Attributes -o src/HashStamp.Attributes
```

**Attribute Definitions**:
```csharp
// HashStampAttribute.cs
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Constructor)]
public class HashStampAttribute : Attribute
{
    public string? CustomName { get; set; }
    public string Algorithm { get; set; } = "SHA256";
    
    public HashStampAttribute() { }
    public HashStampAttribute(string customName) => CustomName = customName;
}

// NoHashStampAttribute.cs  
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Constructor)]
public class NoHashStampAttribute : Attribute { }
```

### Development Workflow

#### Contributing Guidelines

**Before Making Changes**:
1. **Create feature branch**: `git checkout -b feature/your-enhancement-name`
2. **Write tests first**: Add failing tests for new functionality
3. **Implement feature**: Make minimal changes to pass tests
4. **Verify build**: `dotnet build && dotnet test`
5. **Format code**: `dotnet format .`
6. **Run integration tests**: Test with HashStamp.Test project

**Pull Request Checklist**:
- [ ] Tests pass: `dotnet test`
- [ ] Code formatted: `dotnet format --verify-no-changes .`
- [ ] Integration test passes: `dotnet run --project src/HashStamp.Test/HashStamp.Test.csproj`
- [ ] Documentation updated for new features
- [ ] Backward compatibility maintained

### Debugging Source Generator

**Enable Debug Mode**:
```bash
dotnet build --configuration "Debug Source Generator"
```

**Add Debug Code**:
```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
#if DEBUG_SOURCE_GENERATOR
    System.Diagnostics.Debugger.Launch();
#endif
    // Generator logic...
}
```

### Testing Strategy

#### Unit Test Categories

1. **Generator Core Tests**:
   - Hash calculation accuracy
   - Syntax node processing
   - Configuration parsing

2. **Integration Tests**:
   - Full compilation scenarios  
   - Multiple namespace handling
   - Overload resolution

3. **Performance Tests**:
   - Large codebase scenarios
   - Memory usage validation
   - Incremental compilation

#### Sample Test Structure
```
src/HashStamp.Tests/
├── GeneratorTests/
│   ├── CoreGeneratorTests.cs
│   ├── ConfigurationTests.cs
│   └── LanguageConstructTests.cs
├── IntegrationTests/
│   ├── MultiNamespaceTests.cs
│   ├── OverloadTests.cs
│   └── LargeCodebaseTests.cs
├── PerformanceTests/
│   ├── MemoryUsageTests.cs
│   └── IncrementalTests.cs
└── TestData/
    ├── SampleProjects/
    └── ExpectedOutputs/
```

### Common Issues & Solutions

#### Issue: Generator Not Running
**Symptoms**: `HashStamps` class not generated
**Solution**: 
- Verify project reference includes `OutputItemType="Analyzer"`
- Check target framework compatibility
- Enable source generator debugging

#### Issue: Hash Values Inconsistent  
**Symptoms**: Same method produces different hashes
**Solution**:
- Check whitespace normalization
- Verify encoding consistency
- Review method body extraction logic

#### Issue: Build Performance Impact
**Symptoms**: Significantly slower builds
**Solution**:
- Profile generator performance
- Implement incremental compilation properly
- Consider parallel processing for large codebases

### Next Steps Checklist

For immediate implementation focus:

- [ ] **Week 1**: Set up comprehensive testing framework
- [ ] **Week 2**: Implement MSBuild configuration support  
- [ ] **Week 3**: Add property and constructor hashing
- [ ] **Week 4**: Create NuGet package infrastructure
- [ ] **Month 2**: Implement attribute-based control
- [ ] **Month 3**: Add multiple hash algorithm support

### Community Engagement

#### Getting Feedback
- Create GitHub Discussions for feature proposals
- Use Issues for specific bugs and enhancements  
- Engage with .NET source generator community
- Present at developer conferences/meetups

#### Documentation Priorities
1. **API Documentation**: XML docs for all public APIs
2. **Usage Examples**: Real-world scenarios and samples
3. **Migration Guides**: Upgrade paths for major versions
4. **Performance Guide**: Best practices for large codebases

This implementation guide provides the tactical details needed to execute the strategic enhancement plan effectively while maintaining code quality and backward compatibility.