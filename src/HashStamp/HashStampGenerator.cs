using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace HashStamp;

[Generator]
public class HashStampGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG_SOURCE_GENERATOR
        System.Diagnostics.Debugger.Launch();
#endif

        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (context, _) => (MethodDeclarationSyntax)context.Node)
            .Where(m => m is not null);

        var source = context.CompilationProvider.Combine(methodDeclarations.Collect());

        context.RegisterSourceOutput(source, static (ctx, source) => Execute(source.Left, source.Right, ctx));
    }

    private static void Execute(Compilation compilation, ImmutableArray<MethodDeclarationSyntax> methods, SourceProductionContext context)
    {
        List<MethodHashInfo> methodHashes = [];

        foreach (var method in methods)
        {
            var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
            var methodSymbol = semanticModel.GetDeclaredSymbol(method);

            if (methodSymbol is null)
                continue;

            // Get the source code of the method's body, without the signature
            // For expression-bodied methods we need to use the ExpressionBody
            var methodBody = method.Body?.ToFullString()
                ?? method.ExpressionBody?.ToFullString()
                ?? string.Empty;

            var hash = CalculateHash(methodBody);

            methodHashes.Add(new(
                @namespace: methodSymbol.ContainingNamespace.ToDisplayString(),
                className: methodSymbol.ContainingType.Name,
                name: methodSymbol.ToDisplayString(new SymbolDisplayFormat()),
                qualifiedName: methodSymbol.ToDisplayString(new SymbolDisplayFormat(
                    memberOptions: SymbolDisplayMemberOptions.IncludeParameters,
                    parameterOptions: SymbolDisplayParameterOptions.IncludeType)),
                hash: hash));
        }

        context.AddSource($"HashStamps.g.cs", GenerateHashStamps(methodHashes));
    }

    private static string GenerateHashStamps(List<MethodHashInfo> methodHashes)
    {
        static string GenerateNamespace(string @namespace, List<MethodHashInfo> methods)
        {
            static IEnumerable<MethodHashInfo> GetQualifiedHashes(IEnumerable<MethodHashInfo> methodHashes)
            {
                var methodsWithCollidingName = methodHashes
                  .GroupBy(m => m.Name)
                  .Where(g => g.Count() > 1)
                  .Select(g => g.Key)
                  .ToImmutableHashSet();

                string GetMethodName(MethodHashInfo methodHashInfo)
                    => methodsWithCollidingName.Contains(methodHashInfo.Name)
                        ? methodHashInfo.QualifiedName
                        : methodHashInfo.Name;

                foreach (var methodHash in methodHashes)
                {
                    yield return new MethodHashInfo(
                        @namespace: methodHash.Namespace,
                        className: methodHash.ClassName,
                        name: GetMethodName(methodHash),
                        hash: methodHash.Hash,
                        qualifiedName: methodHash.QualifiedName);
                }
            }


            var classConsts = methods
                .GroupBy(m => m.ClassName)
                .Select(m => GenerateClass(m.Key, [.. GetQualifiedHashes(m)]))
                .ToList();

            return $@"
                public partial class {@namespace.Replace(".", "_")}
                {{
                    {string.Join("\r\n", classConsts)}
                }}
            ";
        }

        static string GenerateClass(string className, List<MethodHashInfo> methods)
        {
            var methodHashConsts = methods
                .Select(m => $"public const string {m.Name} = \"{m.Hash}\";")
                .ToList();

            return $@"
                public partial class {className}
                {{
                    {string.Join("\r\n", methodHashConsts)}
                }}
            ";
        }

        var classes = methodHashes
            .GroupBy(m => m.Namespace)
            .Select(g => GenerateNamespace(g.Key, [.. g]))
            .ToList();

        return $@"
        // <auto-generated/>
        using System.Collections.ObjectModel;

        namespace HashStamp;

        public static partial class HashStamps
        {{
            {string.Join("\r\n\t", classes)}

            public static Dictionary<string, NamespaceHashes> Namespaces {{ get; }} = new() {{
                {string.Join("\r\n", methodHashes.GroupBy(h => h.Namespace).Select(nh => $@"[""{nh.Key}""] = new(new() {{
                    {string.Join("\r\n\t\t\t\t\t", nh.GroupBy(h => h.ClassName).Select(ch => $@"[""{ch.Key}""] = new(new() {{
                        {string.Join("\r\n\t\t\t\t\t\t", ch.Select(mhi => $@"[""{mhi.Name}""] = new MethodHash(""{mhi.Hash}""),"))}
                    }}),"))}
                }}),"))}
            }};

        public class ClassHashes(Dictionary<string, MethodHash> methodHashes)
        {{
            public Dictionary<string, MethodHash> Methods {{ get; }} = methodHashes;
        }}

        public class MethodHash(string hash)
        {{
            public string Hash {{ get; }} = hash;
        }}
        
        public class NamespaceHashes(Dictionary<string, ClassHashes> classHashes)
        {{
            public Dictionary<string, ClassHashes> Classes {{ get; }} = classHashes;
        }}
    }}
        ";
    }

    /// <summary>
    /// Calculates a SHA-256 hash of the provided source string and returns it as a lowercase hexadecimal string.
    /// </summary>
    /// <param name="source">The input string to hash.</param>
    /// <returns>The SHA-256 hash of the input as a lowercase hexadecimal string.</returns>
    private static string CalculateHash(string source)
    {
        using var sha256 = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(source);
        var hash = sha256.ComputeHash(bytes);
        return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
    }

    private class MethodHashInfo(string @namespace, string className, string name, string hash, string qualifiedName)
    {
        public string Namespace { get; } = @namespace;
        public string ClassName { get; } = className;
        public string Name { get; } = name;
        public string Hash { get; } = hash;
        public string QualifiedName { get; } = Regex.Replace(qualifiedName, @"[\(\)\.]", "_").TrimEnd("_").ToString();
    }
}
