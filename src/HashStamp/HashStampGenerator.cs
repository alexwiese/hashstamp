using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace HashStamp;

[Generator]
public class HashStampGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG_SOURCE_GENERATOR
        System.Diagnostics.Debugger.Launch();
#endif

        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (context, _) => (MethodDeclarationSyntax)context.Node)
            .Where(m => m is not null);

        var source = context.CompilationProvider.Combine(methodDeclarations.Collect());

        context.RegisterSourceOutput(source, static (ctx, source) => Execute(source.Left, source.Right, ctx));
    }

    private static void Execute(Compilation compilation, ImmutableArray<MethodDeclarationSyntax> methods, SourceProductionContext context)
    {
        List<MethodHashInfo> methodHashes = [];

        foreach (var method in methods)
        {
            var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
            var methodSymbol = semanticModel.GetDeclaredSymbol(method);

            if (methodSymbol is null)
                continue;

            // Get the source code of the method's body, without the signature
            // For expression-bodied methods we need to use the ExpressionBody
            var methodBody = method.Body?.ToFullString()
                ?? method.ExpressionBody?.ToFullString()
                ?? string.Empty;

            var hash = CalculateHash(methodBody);

            var qualifiedName = methodSymbol.ToDisplayString(new SymbolDisplayFormat(
                memberOptions: SymbolDisplayMemberOptions.IncludeParameters,
                parameterOptions: SymbolDisplayParameterOptions.IncludeType));

            methodHashes.Add(new(
                @namespace: methodSymbol.ContainingNamespace.ToDisplayString(),
                className: methodSymbol.ContainingType.Name,
                name: methodSymbol.ToDisplayString(new SymbolDisplayFormat()),
                qualifiedName: qualifiedName,
                hash: hash,
                signature: qualifiedName));
        }

        context.AddSource($"HashStamps.g.cs", GenerateHashStamps(methodHashes));
    }

    private static string GenerateHashStamps(List<MethodHashInfo> methodHashes)
    {
        static void GenerateNamespace(StringBuilder sb, string @namespace, List<MethodHashInfo> methods)
        {
            static IEnumerable<MethodHashInfo> GetQualifiedHashes(IEnumerable<MethodHashInfo> methodHashes)
            {
                var methodsWithCollidingName = methodHashes
                  .GroupBy(m => m.Name)
                  .Where(g => g.Count() > 1)
                  .Select(g => g.Key)
                  .ToImmutableHashSet();

                string GetMethodName(MethodHashInfo methodHashInfo)
                    => methodsWithCollidingName.Contains(methodHashInfo.Name)
                        ? methodHashInfo.QualifiedName
                        : methodHashInfo.Name;

                foreach (var methodHash in methodHashes)
                {
                    yield return new MethodHashInfo(
                        @namespace: methodHash.Namespace,
                        className: methodHash.ClassName,
                        name: GetMethodName(methodHash),
                        hash: methodHash.Hash,
                        qualifiedName: methodHash.QualifiedName,
                        signature: methodHash.Signature);
                }
            }

            sb.AppendLine($"                public partial class {@namespace.Replace(".", "_")}");
            sb.AppendLine("                {");
            
            foreach (var classGroup in methods.GroupBy(m => m.ClassName))
            {
                GenerateClass(sb, classGroup.Key, [.. GetQualifiedHashes(classGroup)]);
            }
            
            sb.AppendLine("                }");
        }

        static void GenerateClass(StringBuilder sb, string className, List<MethodHashInfo> methods)
        {
            sb.AppendLine($"                public partial class {className}");
            sb.AppendLine("                {");
            
            foreach (var method in methods)
            {
                sb.AppendLine($"                    public const string {method.Name} = \"{method.Hash}\";");
            }
            
            sb.AppendLine("                }");
        }

        var sb = new StringBuilder();
        sb.AppendLine("        // <auto-generated/>");
        sb.AppendLine("        using System.Collections.Generic;");
        sb.AppendLine("        using System.Collections.ObjectModel;");
        sb.AppendLine();
        sb.AppendLine("        namespace HashStamp;");
        sb.AppendLine();
        sb.AppendLine("        public static partial class HashStamps");
        sb.AppendLine("        {");

        foreach (var namespaceGroup in methodHashes.GroupBy(m => m.Namespace))
        {
            GenerateNamespace(sb, namespaceGroup.Key, [.. namespaceGroup]);
        }

        sb.AppendLine();
        sb.AppendLine("            public static Dictionary<string, NamespaceHashes> Namespaces { get; } = new() {");
        
        foreach (var namespaceGroup in methodHashes.GroupBy(h => h.Namespace))
        {
            sb.AppendLine($"                [\"{namespaceGroup.Key}\"] = new(new() {{");
            foreach (var classGroup in namespaceGroup.GroupBy(h => h.ClassName))
            {
                sb.AppendLine($"                    [\"{classGroup.Key}\"] = new(new() {{");
                foreach (var method in classGroup)
                {
                    sb.AppendLine($"                        [\"{method.Name}\"] = new MethodHash(\"{method.Hash}\", \"{method.Signature}\"),");
                }
                sb.AppendLine("                    }),");
            }
            sb.AppendLine("                }),");
        }
        
        sb.AppendLine("            };");
        sb.AppendLine();
        sb.AppendLine("        public class ClassHashes(Dictionary<string, MethodHash> methodHashes)");
        sb.AppendLine("        {");
        sb.AppendLine("            public Dictionary<string, MethodHash> Methods { get; } = methodHashes;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public class MethodHash(string hash, string signature)");
        sb.AppendLine("        {");
        sb.AppendLine("            public string Hash { get; } = hash;");
        sb.AppendLine("            public string Signature { get; } = signature;");
        sb.AppendLine("        }");
        sb.AppendLine("        ");
        sb.AppendLine("        public class NamespaceHashes(Dictionary<string, ClassHashes> classHashes)");
        sb.AppendLine("        {");
        sb.AppendLine("            public Dictionary<string, ClassHashes> Classes { get; } = classHashes;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        
        return sb.ToString();
    }

    /// <summary>
    /// Calculates a SHA-256 hash of the provided source string and returns it as a lowercase hexadecimal string.
    /// </summary>
    /// <param name="source">The input string to hash.</param>
    /// <returns>The SHA-256 hash of the input as a lowercase hexadecimal string.</returns>
    private static string CalculateHash(string source)
    {
        using var sha256 = SHA256.Create();
        var sourceBytes = Encoding.UTF8.GetBytes(source);
        var hashBytes = sha256.ComputeHash(sourceBytes);

        // Use a more efficient hex conversion than StringBuilder
        const string hexLookup = "0123456789abcdef";
        var result = new char[hashBytes.Length * 2];
        
        for (int i = 0; i < hashBytes.Length; i++)
        {
            var b = hashBytes[i];
            result[i * 2] = hexLookup[b >> 4];
            result[i * 2 + 1] = hexLookup[b & 0xF];
        }
        
        return new string(result);
    }

    private class MethodHashInfo(string @namespace, string className, string name, string hash, string qualifiedName, string signature)
    {
        private static readonly Regex QualifiedNameRegex = new(@"[\(\)\.]", RegexOptions.Compiled);

        public string Namespace { get; } = @namespace;
        public string ClassName { get; } = className;
        public string Name { get; } = name;
        public string Hash { get; } = hash;
        public string QualifiedName { get; } = QualifiedNameRegex.Replace(qualifiedName, "_").TrimEnd('_');
        public string Signature { get; } = signature;
    }
}
