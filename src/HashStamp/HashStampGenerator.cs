using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace HashStamp;

[Generator]
public class HashStampGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG_SOURCE_GENERATOR
        DebuggerUtil.AttachDebugger();
#endif

        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (context, _) => (MethodDeclarationSyntax)context.Node)
            .Where(m => m is not null);

        var source = context.CompilationProvider.Combine(methodDeclarations.Collect());

        context.RegisterSourceOutput(source, static (ctx, source) => Execute(source.Left, source.Right, ctx));
    }

    private class MethodHashInfo(string @namespace, string className, string name, string hash)
    {
        public string Namespace { get; } = @namespace;
        public string ClassName { get; } = className;
        public string Name { get; } = name;
        public string Hash { get; } = hash;
    }

    private static void Execute(Compilation compilation, ImmutableArray<MethodDeclarationSyntax> methods, SourceProductionContext context)
    {
        List<MethodHashInfo> methodHashes = [];

        foreach (var method in methods)
        {
            var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
            var methodSymbol = semanticModel.GetDeclaredSymbol(method);

            if (methodSymbol is null)
                continue;

            // Get the source code of the method's body, without the signature
            var methodBody = method.Body?.ToFullString() ?? string.Empty;

            var hash = CalculateHash(methodBody);

            methodHashes.Add(new(methodSymbol.ContainingNamespace.ToDisplayString(), methodSymbol.ContainingType.Name, methodSymbol.Name, hash));
        }

        context.AddSource($"HashStamps.g.cs", GenerateHashStamps(methodHashes));

    }

    private static string GenerateHashStamps(List<MethodHashInfo> methodHashes)
    {
        static string GenerateNamespace(string @namespace, List<MethodHashInfo> methods)
        {
            var classConsts = methods
                .GroupBy(m => m.ClassName)
                .Select(m => GenerateClass(m.Key, m.ToList()))
                .ToList();

            return $@"
                public partial class {@namespace.Replace(".", "_")}
                {{
                    {string.Join("\r\n", classConsts)}
                }}
            ";
        }

        static string GenerateClass(string className, List<MethodHashInfo> methods)
        {
            var methodHashConsts = methods
                .Select(m => $"public const string {m.Name} = \"{m.Hash}\";")
                .ToList();

            return $@"
                public partial class {className}
                {{
                    {string.Join("\r\n", methodHashConsts)}
                }}
            ";
        }

        var classes = methodHashes
            .GroupBy(m => m.Namespace)
            .Select(g => GenerateNamespace(g.Key, g.ToList()))
            .ToList();

        return $@"
        // <auto-generated/>
        using System.Collections.ObjectModel;

        namespace HashStamp;

        public static partial class HashStamps
        {{
            {string.Join("\r\n\t", classes)}

            public static Dictionary<string, NamespaceHashes> Namespaces {{ get; }} = new() {{
                {string.Join("\r\n", methodHashes.GroupBy(h => h.Namespace).Select(nh => $@"[""{nh.Key}""] = new(new() {{
                    {string.Join("\r\n\t\t\t\t\t", nh.GroupBy(h => h.ClassName).Select(ch => $@"[""{ch.Key}""] = new(new() {{
                        {string.Join("\r\n\t\t\t\t\t\t", ch.Select(mhi => $@"[""{mhi.Name}""] = new MethodHash(""{mhi.Hash}""),"))}
                    }}),"))}
                }}),"))}
            }};

        public class ClassHashes(Dictionary<string, MethodHash> methodHashes)
        {{
            public Dictionary<string, MethodHash> Methods {{ get; }} = methodHashes;
        }}

        public class MethodHash(string hash)
        {{
            public string Hash {{ get; }} = hash;
        }}
        
        public class NamespaceHashes(Dictionary<string, ClassHashes> classHashes)
        {{
            public Dictionary<string, ClassHashes> Classes {{ get; }} = classHashes;
        }}
    }}
        ";
    }

    private static string CalculateHash(string source)
    {
        using var sha256 = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(source);
        var hash = sha256.ComputeHash(bytes);
        return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
    }
}
